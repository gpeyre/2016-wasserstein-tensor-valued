%%
% Test for anisotropic meshing.

addpath('toolbox/');
addpath('toolbox_quantum/');
addpath('toolbox_fast_marching/');
addpath('toolbox_quantum/tensor_logexp/');
addpath('data/images/');

name = 'circular';
name = '2d-bump-donut';
name = 'images';

rep = ['results/meshing/' name '/'];
[~,~] = mkdir(rep);

%%
% Load input measures.

n = 20; % Size for Sinkhorn computation
n1 = 256; % Size of the underlying grid for FM computation.


options.order = 1;

dXf = @(f)f([2:end end],:) - f;
dXb = @(f)f - f([1 1:end-1],:);
dXc = @(f)( f([2:end end],:) - f([1 1:end-1],:) )/2;
dXX = @(f)dXf(dXb(f));
dYc = @(f)dXc(f')';
dYY = @(f)dXX(f')';
dXY = @(f)dXc(dYc(f));
Hess = @(f)permute( reshape(cat(3, dXX(f), dXY(f), dXY(f), dYY(f)), [n1 n1 2 2]), [3 4 1 2]);


switch name
    case 'images'
        name_img = {'cartoon' 'hibiscus'};
        for k=1:2
            f0{k} = load_image(name_img{k}, n1);
            f0{k} = rescale(sum(f0{k},3));
            % use hessian
            sigma = 2;
            Mu0{k} = Hess( perform_blurring(f0{k},sigma) );
            % remapping function for the eigenvalue, typically should be |.|
            [e1,e2,l1,l2] = tensor_eigendecomp(Mu0{k});
            v = max(abs(l1(:)));
            alpha = 1; beta = 1.5; vmin = .01;
            phi = @(x)vmin + abs(x/v).^alpha;
            psi = @(x)vmin + abs(x/v).^beta;
            Mu0{k} = tensor_eigenrecomp(e1,e2,psi(l2),phi(l1));
            % blur & sub-sample
            sigma = 3*n1/n;
            Mu = {};  Mu1 = {};
            for a=1:2
                for b=1:2
                    g = squeeze(Mu0{k}(a,b,:,:));
                    g = perform_blurring(g, sigma, options);
                    Mu1{k}(a,b,:,:) = g;
                    g = image_resize(g,[n n 1]);
                    Mu{k}(a,b,:,:) = reshape(g, [1 1 n n]);
                end
            end            
            mu{k} = reshape(Mu{k},[2 2 n*n]);
            % display
            clf;  
            opt.nb_ellipses = n; 
            opt.image = f0{k};
            plot_tensors_2d( Mu{k}, opt );           
            saveas(gcf, [rep 'input-images-' num2str(k) '.png'], 'png')
        end
        
    otherwise
        Mu = load_tensors_pair(name, n);
        mu = {};
        vmin = .03; % increase to avoid too rough variatons
        for k=1:2
            [e1,e2,l1,l2] = tensor_eigendecomp(Mu{k});
            Mu{k} = tensor_eigenrecomp(e1,e2,vmin+l1,vmin+l2);
            mu{k} = reshape(Mu{k},[2 2 n*n]);
        end
end

%%
% Sinkhorn.

c = ground_cost(n,2); % Ground cost
epsilon = (.06)^2;  % regularization
rho = 1;  % fidelity
options.niter = 500; % ok for .05^2
options.disp_rate = NaN;
options.tau = 1.8*epsilon/(rho+epsilon);  % prox step, use extrapolation to seed up
[gamma,u,v,err] = quantum_sinkhorn(mu{1},mu{2},c,epsilon,rho, options);

%%
% Compute interpolation using an heuristic McCann-like formula.

m = 9;
opt.sparse_mult = 100; % controls number of travelling Diracs
opt.disp_tensors = 1;
nu = compute_quantum_interp(gamma, mu, m, 2, opt);

%%
% Display anisotropic mesh according to the interpolated metrics.

P = 200; % #sampling points, high density
P1 = 25; % low density
for k=1:m
    % up-sample
    op = load_helpers(n);
    T = op.C2T(reshape(nu{k}, [2 2 n n]));
    T = image_resize(T,[n1 n1 3]);
    Mu = op.T2C(T);
    % do the sampling
    [X,D,Vor,v] = farthesh_point(Mu,P);    
    % display    
    opt.nb_contours = 0;
    clf; disp_farthest_sampling(D,X,v, 'voronoi', opt);
    saveas(gcf, [rep 'input-voronoi-' num2str(k) '.png'], 'png');
    clf; disp_farthest_sampling(D,X,v, 'mesh');
    saveas(gcf, [rep 'input-mesh-' num2str(k) '.png'], 'png');
    % for first/last frame, overlay the background image if a
    % just a few samples
    [X,D,Vor,v] = farthesh_point(Mu,P1);
    opt.nb_contours = 12;
    clf; disp_farthest_sampling(D,X,v, 'voronoi', opt);  
    saveas(gcf, [rep 'input-contours-' num2str(k) '.png'], 'png');  
end

